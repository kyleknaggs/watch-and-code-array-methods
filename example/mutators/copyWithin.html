<script src="../../simpletest.js"></script>
<script>
  // Summary:
  // Shallow copies part of an array to another location in the same array.

  // Example:
  // var array = ["a", "b", "c", "d"];
  // copyWithin(array, 1, 2, 3);
  // >>> ["a", "c", "c", "d"];

  // Prototype implementation:

  // function copyWithin() {
  // }

  // Function signature:
  // copyWithin(array, indexToCopyTo, optionalStart, optionalEnd);

  // Arguments:
  // array - The array to be modified.
  // indexToCopyTo - The index to insert copied elements at.
  // optionalStart - The index to begin copying elements from.
  // optionalEnd - The index to stop copying elements at.

  // Return value:
  // The array that was modified.

  // Requirements:
  // Questions:
  // 1) What does shallow copy mean? https://we-are.bookmyshow.com/understanding-deep-and-shallow-copy-in-javascript-13438bad941c
  // A "shallow copy" is a copy of an object that points to the same memory address.
  // A "deep copy" is a copy of an object that is stored at a new memory address.
  // 2) What is a TypedArray? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/copyWithin
  // A TypedArray object describes an array-like view of an underlying binary data buffer.
  // 3) What is a binary data buffer? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
  // The ArrayBuffer object is used to represent a generic, fixed-length raw binary data buffer.

  // Useful References:
  // 1) MDN Docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin s
  // 2) Specs: https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.copywithin
  // 3) Type Array Docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/copyWithin

  // Function Syntax:

  function copyWithin() {}

  tests({
    // Basic Requirements:
    "1) It should return an array.": function() {
      fail();
      // var array = [];
      // var returnedArray = copyWithin(array);
      // eq(Object.prototype.toString.call(returnedArray), "[object Array]");
    },
    "2) It should return the same array instead of creating a new array.": function() {
      fail();
      // var array = [];
      // var returnedArray = copyWithin(array);
      // eq(array, returnedArray);
    },

    // If indexToCopyTo is a number:
    "3a) If (indexToCopyTo === 0 ) it should NOT copy any elements in array.": function() {
      fail();
      // var array = ["a", "b"];
      // var indexToCopyTo = 0;
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(returnedArray[0], "a")
      // eq(returnedArray[1], "b")
    },
    "3b) If (indexToCopyTo > 0) && (indexToCopyTo < array.length), it should copy array[n], to array[n + indexToCopyTo].": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(deepCopyOfOrginalArray[0] === returnedArray[indexToCopyTo + 0], true);
      // eq(deepCopyOfOrginalArray[1] === returnedArray[indexToCopyTo + 1], true);
    },
    "3c) If (indexToCopyTo > 0) && (indexToCopyTo >= array.length), it should NOT copy any elements in array.": function() {
      fail();
      // var array = ["a", "b"];
      // var indexToCopyTo = 2;
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(returnedArray[0], "a")
      // eq(returnedArray[1], "b")
    },
    "3d) If (indexToCopyTo < 0) && (indexToCopyTo + array.length > 0), it should copy array[n] to array[array.length + indexToCopyTo + n].": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = -1;
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(deepCopyOfOrginalArray[0] === returnedArray[deepCopyOfOrginalArray.length + indexToCopyTo + 0], true);
    },
    "3e) If (indexToCopyTo < 0) && (indexToCopyTo + array.length <= 0), it should copy array[n] to array[array.length + indexToCopyTo + n].": function() {
      fail();
      // var array = ["a", "b"];
      // var indexToCopyTo = -2;
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(returnedArray[0], "a")
      // eq(returnedArray[1], "b")
    },

    // If indexToCopyTo is not a number:
    "4a) If indexToCopyTo is not a number && indexToCopyTo can be converted to a number it should behave like Number(indexToCopyTo)": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = "1";
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(deepCopyOfOrginalArray[0] === returnedArray[indexToCopyTo + 0], true);
      // eq(deepCopyOfOrginalArray[1] === returnedArray[indexToCopyTo + 1], true);
    },
    "4b) If indexToCopyTo is not a number && indexToCopyTo cannot be converted to a number, it should NOT copy indexes.": function() {
      fail();
      // var array = ["a", "b"];
      // var indexToCopyTo = "cow";
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(returnedArray[0], "a")
      // eq(returnedArray[1], "b")
    },

    // If optionalStart is a number:
    "5a) If no optionalStart, the first copied index should be array[0].": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(deepCopyOfOrginalArray[0] === returnedArray[indexToCopyTo], true);
    },
    "5b) If (optionalStart >= 0) && (optionalStart < array.length), the first copied index should be array[optionalStart].": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var optionalStart = 1;
      // var indexToCopyTo = 0;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart);
      // eq(deepCopyOfOrginalArray[optionalStart] === returnedArray[indexToCopyTo], true);
    },
    "5c) If (optionalStart >= 0) && (optionalStart >= array.length), do not copy indexes": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var optionalStart = 3;
      // var indexToCopyTo = 0;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart);
      // eq(deepCopyOfOrginalArray[0] === returnedArray[indexToCopyTo] === false);
    },
    "5d) If (optionalStart < 0) && (optionalStart + array.length > 0), the first copied index should be array[array.length + optionalStart].": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var optionalStart = -1;
      // var returnedArray = copyWithin(array, 0, optionalStart);
      // eq(deepCopyOfOrginalArray[array.length+optionalStart] === returnedArray[0], true);
    },
    "5e) If (optionalStart < 0) && (optionalStart + array.length <= 0), do not copy indexes.": function() {
      fail();
      // var array = ["a", "b"];
      // var optionalStart = -2;
      // var returnedArray = copyWithin(array, indexToCopyTo);
      // eq(returnedArray[0], "a")
      // eq(returnedArray[1], "b")
    },

    // If optionalStart is not a number:
    "6a) If optionalStart is not a number && optionalStart can be converted to a number, it should behave like Number(optionalStart).": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var optionalStart = "1";
      // var indexToCopyTo = 0;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart);
      // eq(deepCopyOfOrginalArray[optionalStart] === returnedArray[indexToCopyTo], true);
    },
    "6b) If optionalStart is not a number && optionalStart cannnot be converted to a number, it should NOT copy indexes.": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var optionalStart = "cow";
      // var indexToCopyTo = 0;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart);
      // eq(returnedArray[0], "a";
      // eq(returnedArray[1], "b";
      // eq(returnedArray[2], "c";
    },

    // If optionalEnd is a number:
    "7a) If no optionalEnd, all indexes after optionalStart should be copied.": function() {
      fail();
      // var array = ["a", "b", "c", "d"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var optionalStart = 0;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart);
      // eq(deepCopyOfOrginalArray[optionalStart], returnedArray[optionalStart + indexToCopyTo]);
      // eq(deepCopyOfOrginalArray[optionalStart + 1], returnedArray[optionalStart + indexToCopyTo + 1]);
      // eq(deepCopyOfOrginalArray[optionalStart + 2], returnedArray[optionalStart + indexToCopyTo + 2]);
    },
    "7b) If (optionalEnd >= 0) the last copied index should be array[optionalEnd - 1].": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var optionalStart = 0;
      // var optionalEnd = 1;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart, optionalEnd);
      // eq(deepCopyOfOrginalArray[optionalEnd - 1] === returnedArray[indexToCopyTo + optionalEnd - 1], true);
      // eq(deepCopyOfOrginalArray[optionalEnd] === returnedArray[indexToCopyTo + optionalEnd], false);
    },
    "7c) If (optionalEnd < 0) && (optionalEnd + array.length > 0), the last copied index should be array[optionalEnd + array.length - 1]": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var optionalStart = 0;
      // var optionalEnd = -2;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart, optionalEnd);
      // eq(deepCopyOfOrginalArray[optionalEnd + array.length - 1] === returnedArray[indexToCopyTo + optionalEnd + array.length - 1], true);
      // eq(deepCopyOfOrginalArray[optionalEnd + array.length ] === returnedArray[indexToCopyTo + optionalEnd + array.length], false);
    },
    "7d) If (optionalEnd < 0) && (optionalEnd + array.length < 0), it should NOT copy all remaining elements in array.": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var optionalStart = 0;
      // var optionalEnd = -3;
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart, optionalEnd);
      // eq(returnedArray[0], "a")
      // eq(returnedArray[1], "b")
      // eq(returnedArray[2], "c")
    },

    // If optionalEnd is not a number:
    "8a) If optionalEnd is not a number && optionalEnd can be converted to a number, it should behave like Number(optionalEnd).": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var optionalStart = 0;
      // var optionalEnd = "1";
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart, optionalEnd);
      // eq(deepCopyOfOrginalArray[optionalEnd - 1] === returnedArray[indexToCopyTo + optionalEnd - 1], true);
      // eq(deepCopyOfOrginalArray[optionalEnd] === returnedArray[indexToCopyTo + optionalEnd], false);
    },
    "8b) If optionalEnd is not a number && optionalEnd cannnot be converted to a number, it should NOT copy indexes.": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var deepCopyOfOrginalArray = array.slice();
      // var indexToCopyTo = 1;
      // var optionalStart = 0;
      // var optionalEnd = "cow";
      // var returnedArray = copyWithin(array, indexToCopyTo, optionalStart, optionalEnd);
      // eq(returnedArray[0], "a")
      // eq(returnedArray[1], "b")
      // eq(returnedArray[2], "c")
    },

    "9) It should never modify array.length.": function() {
      fail();
      // var array = ["a", "b", "c"];
      // var originalLength = array.length;
      // var returnedArray = copyWithin(array, 2);
      // eq(originalLength, returnedArray.length);

      // var array = ["a", "b", "c"];
      // var originalLength = array.length;
      // var returnedArray = copyWithin(array, 2, 0);
      // eq(originalLength, returnedArray.length);

      // var array = ["a", "b", "c"];
      // var originalLength = array.length;
      // var returnedArray = copyWithin(array, 2, 0, 2);
      // eq(originalLength, returnedArray.length);
    },

    "10) It should shallow copy part of array, creating a copies of objects that point to the same memory address": function() {
      fail();
      // var object = {};
      // var array = [object, "b", "c"];
      // var returnedArray = copyWithin(array, 1);
      // object.isShallowCopyOfObject = true;
      // eq(returnedArray[1].isShallowCopyOfObject, true);
    },

    // TODO: 4) Test function using .call() & .apply().

    // When used with call() and apply():
    "8a) It should work with .call().": function() {
      fail();
    },
    "8b) It should work with .apply().": function() {
      fail();
    },

    // TODO: 5) Test function with array-like objects.

    // When used with objects:
    "9)If object has object.length, it should copyWithin().": function() {
      fail();
    }

    // TODO: 6) Test function for edge cases listed in document.

    // TODO: 7) Test function for non-object or array-like arguments.
  });
</script>
