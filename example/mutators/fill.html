<script src="../../simpletest.js"></script>
<script>
  // Summary:
  //  Fills all the elements of an array from a start index to an end index with a static value.

  // Example:
  // var array = [0,1];
  // fill(array, 2)
  // >> returns [2,2]
  // >> array === [2,2]

  // Prototype implementation:

  // function fill(array, value, optionalStart, optionalEnd) {
  //   var startingIndex = 0;
  //   var endingIndex = array.length;

  //   if (optionalStart) {
  //     startingIndex = optionalStart;
  //   }

  //   if (optionalEnd) {
  //     startingIndex = optionalEnd;
  //   }

  //   for (var i = startingIndex; i < endingIndex; i++) {
  //     array[i] = value;
  //   }

  //   return array;
  // }

  // Function signature:
  // fill(array, value, optionalStart, optionalEnd);

  // Arguments:
  // array - The array to be modified.
  // value - The value used to fill the array.
  // optionalStart - Starting index for the insertion of value. Defaults to 0.
  // optionalEnd - Ending index for the insertion of value. Defaults to array.length.

  // Return value:
  // The modified array.

  // Requirements:

  // Questions:
  // 1) What is a polyfill?
  // https://developer.mozilla.org/en-US/docs/Glossary/Polyfill
  // A polyfill is a piece of code, usually JS on the web, used to provide modern functionality to old browsers that do not support it.
  // https://www.youtube.com/watch?v=kJZFEI67HoM
  // A script that is conditionally injected into a browser if an older browser does not support a specific bit of modern functionality.

  // Function Syntax:

  function fill(array, value, optionalStart, optionalEnd) {
    var classOfThis = Object.prototype.toString.call(this);
    // Need to shift value of optionalStart && optionalEnd
    var objectToModify, valueToFill, startingIndex, endingIndex;

    if (classOfThis !== "[object Window]") {
      objectToModify = this;
      valueToFill = arguments[0];
    } else {
      objectToModify = array;
      valueToFill = value;
    }

    startingIndex = 0;

    if (optionalStart < 0) {
      startingIndex = array.length + optionalStart;
    } else if (optionalStart >= 0) {
      startingIndex = optionalStart;
    }

    endingIndex = objectToModify.length;

    if (optionalEnd < 0) {
      endingIndex = array.length + optionalEnd;
    } else if (optionalEnd >= 0) {
      endingIndex = optionalEnd;
    }

    for (var i = startingIndex; i < endingIndex; i++) {
      array[i] = valueToFill;
    }

    return array;
  }

  tests({
    "1a) It should return an array.": function() {
      var originalArray = [];
      var filledArray = fill(originalArray);
      eq(Object.prototype.toString.call(filledArray), "[object Array]");
    },

    "2a) It should return the same array instead of creating a new array.": function() {
      var originalArray = [];
      var filledArray = fill(originalArray);
      eq(originalArray, filledArray);
    },

    "3a) It should fill elements with value.": function() {
      var originalArray = [0];
      var filledArray = fill(originalArray, "a");
      eq(filledArray[0], "a");

      var originalArray = [0, 1];
      var filledArray = fill(originalArray, "a");
      eq(filledArray[0], "a");
      eq(filledArray[1], "a");
    },

    "4a) It should fill holes in array.": function() {
      var arrayWithHoles = [, , ,];
      var filledArray = fill(arrayWithHoles, "a");
      eq(filledArray[0], "a");
      eq(filledArray[1], "a");
      eq(filledArray[2], "a");

      var arrayWithHoles = [0, , 2];
      var filledArray = fill(arrayWithHoles, "a");
      eq(filledArray[1], "a");
    },

    "5a) If value is an object, pass reference to object instead of a shallow copy of object.": function() {
      var originalArray = [0];
      var originalObject = {};
      var filledArray = fill(originalArray, originalObject);
      eq(filledArray[0], originalObject);
    },

    "6a) If value contains a nested array, fill should contain nested array.": function() {
      var originalArray = ["originalArray"];
      var nestedArray = ["nestedArray"];
      var array = ["array", nestedArray];
      var filledArray = originalArray.fill(array);
      eq(filledArray[0], array);
      eq(filledArray[0][1], nestedArray);
    },

    "7a) If no optionalStart, it should start filling indexes at array[0].": function() {
      var originalArray = [0, 1];
      var filledArray = fill(originalArray, "a");
      eq(filledArray[0], "a");
    },
    "7b) If optionalStart, it should start filling indexes at array[optionalStart].": function() {
      var originalArray = [0, 1];
      var filledArray = fill(originalArray, "a", 1);
      eq(filledArray[0], 0);
      eq(filledArray[1], "a");
    },

    "8a) If no optionalEnd, it should fill all remaining indexes in array.": function() {
      var originalArray = [0, 1];
      var filledArray = fill(originalArray, "a", 0);
      for (var i = 0; i < filledArray.length; i++) {
        eq(filledArray[i], "a");
      }
    },
    "9b) If optionalEnd, it should fill all indexes until array[optionalEnd].": function() {
      var originalArray = [0, 1];
      var filledArray = fill(originalArray, "a", 0, 1);
      eq(filledArray[0], "a");
      eq(filledArray[1], 1);
    },

    "10a) If optionalStart is negative, start fill at array.length + optionalStart.": function() {
      var originalArray = [0, 1, 2];
      var filledArray = fill(originalArray, "a", -1);
      eq(filledArray[0], 0);
      eq(filledArray[1], 1);
      eq(filledArray[2], "a");

      var originalArray = [0, 1, 2];
      var filledArray = fill(originalArray, "a", -2);
      eq(filledArray[0], 0);
      eq(filledArray[1], "a");
      eq(filledArray[2], "a");
    },
    "10b) If optionalEnd is negative, end fill at array.length + optionalEnd.": function() {
      var originalArray = [0, 1, 2];
      var filledArray = fill(originalArray, "a", 0, -1);
      eq(filledArray[0], "a");
      eq(filledArray[1], "a");
      eq(filledArray[2], 2);

      var originalArray = [0, 1, 2];
      var filledArray = fill(originalArray, "a", 0, -2);
      eq(filledArray[0], "a");
      eq(filledArray[1], 1);
      eq(filledArray[2], 2);
    },

    "11a) It should fill with .call().": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, "a");
      // eq(originalArray[0] && originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, "a", 1);
      // eq(originalArray[0], 0);
      // eq(originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, "a", 1, 2);
      // eq(originalArray[0], 0);
      // eq(originalArray[1], "a");
      // eq(originalArray[2], 2);
    },
    "11b) It should fill with .apply().": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, ["a"]);
      // eq(originalArray[0] && originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, ["a", 1]);
      // eq(originalArray[0], 0);
      // eq(originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, ["a", 1, 2]);
      // eq(originalArray[0], 0);
      // eq(originalArray[1], "a");
      // eq(originalArray[2], 2);
    },

    "12a) If array is object and object has no length, object should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //   0:0
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 0);
    },
    "12b) If array is object and object.length is <= 0, object should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   length: -10
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 0);
    },
    "12c) If array is object and object.length is > 0, fill indexes up to object.length - 1.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   1:1,
      //   length: 1
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
      // eq(modifiedObject[1], 1);

      // var originalObject = {
      //   0:0,
      //   1:1,
      //   length: 2
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
      // eq(modifiedObject[1], 'a');

      // var originalObject = {
      //   0:0,
      //   1:1,
      //   length: 3
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
      // eq(modifiedObject[1], 'a');
      // eq(modifiedObject[2], 'a');
    },
    "12d) If array is object and object.length is a string, and object.length can be converted to a number, fill indexes up to Number(object.length) - 1.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   length: '1'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
    },
    "12e) If array is object and object.length is a string, and object.length cannot be converted to a number, object should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   length: 'cow'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 0);
    },

    "13a) If array is object it should never modify object.length.": function() {
      fail();
      // var originalObject = {
      //   0:0
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.hasOwnProperty("length"), false);

      // var originalObject = {
      //   0:0,
      //   length: -10
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, -10);

      // var originalObject = {
      //   0:0,
      //   length: 1
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, 1);

      // var originalObject = {
      //   0:0,
      //   length: 2
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, 2);

      // var originalObject = {
      //   0:0,
      //   length: '1'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, '1');

      // var originalObject = {
      //   0:0,
      //   length: 'cow'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, 'cow');
    },

    "14a) It array is a string it should throw TypeError that states: Uncaught TypeError Cannot assign to read only property '0' of object '[object String]'. ": function() {
      fail();
      // var isTypeError = false;
      // try {
      //   var string = "string";
      //   fill.call(string, "a");
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    },
    "14b) It array is null or undefined it should throw TypeError that states: Uncaught TypeError Cannot convert undefined or null to object. ": function() {
      fail();
      // var isTypeError = false;
      // try {
      //   var testNull = null;
      //   fill.call(testNull, "a");
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);

      // var isTypeError = false;
      // try {
      //   var testUndefined = undefined;
      //   fill.call(testUndefined, "a");
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    },
    "14c) If array is a function, it should return function.": function() {
      fail();
      // var testFunction = function () {};
      // var filledFunction = Array.prototype.fill.call(testFunction, 'a');
      // eq(testFunction, filledFunction)
    },

    "14d) If array is number or a boolean, it should convert array to object and return that?!": function() {
      fail();
      // TODO: 2) Figure out what happens with conversion of primitive to object.

      // Notes:
      // Spec: https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.fill
      // First step in Array.prototype.fill() is "Let O be ToObject(this value)."
      // Spec on ToObject method used in Array.prototype.fill(): https://www.ecma-international.org/ecma-262/6.0/#sec-toobject
      // The abstract operation ToObject converts argument to a value of type Object according to Table 13:
      // TODO: 1) Read this article. It appears to be very useful and sheds light on converting primtives to objects in JS:
      // JavaScript: Converting any value to an object: http://2ality.com/2011/04/javascript-converting-any-value-to.html

      // var number = 1;
      // var filledNumber = Array.prototype.fill.call(number, "a");
      // >>> returns {1}

      // var bool = true;
      // var filledBool = Array.prototype.fill.call(true, 'a');
      // >>> returns {true}
    }
  });
</script>
