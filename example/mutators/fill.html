<script src="../../simpletest.js"></script>
<script>
  // Summary:
  //  Fills all the elements of an array from a start index to an end index with a static value.

  // Example:
  // var array = [0,1];
  // fill(array, 2)
  // >> returns [2,2]
  // >> array === [2,2]

  // Prototype implementation:

  // function fill() {
  // }

  // Function signature:
  // fill(array, value, optionalStart, optionalEnd);

  // Arguments:
  // array - The array to be modified.
  // value - The value used to fill the array.
  // optionalStart - Starting index for the insertion of valueToFill. Defaults to 0.
  // optionalEnd - Ending index for the insertion of valueToFill. Defaults to array.length.

  // Return value:
  // The modified array.

  // Requirements:

  // Questions:
  // 1) What is a polyfill?
  // https://developer.mozilla.org/en-US/docs/Glossary/Polyfill
  // A polyfill is a piece of code, usually JS on the web, used to provide modern functionality to old browsers that do not support it.
  // https://www.youtube.com/watch?v=kJZFEI67HoM
  // A script that is conditionally injected into a browser if an older browser does not support a specific bit of modern functionality.

  // Function Syntax:
  // function fill() {}

  // TODO: 3) What happens if there is a nested array inside of array?.
  // TODO: 4) Organize and number tests.

  tests({
    "a) It should return an array.": function() {
      fail();
      // var originalArray = [];
      // var filledArray = fill(originalArray);
      // eq(Object.prototype.toString.call(filledArray), "[object Array]")
    },

    "a) It should return the same array instead of creating a new array.": function() {
      fail();
      // var originalArray = [];
      // var filledArray = fill(originalArray);
      // eq(originalArray, filledArray);
    },

    "a) It should fill elements with value.": function() {
      fail();
      // var originalArray = [0];
      // var filledArray = fill(originalArray, 'a');
      // eq(filledArray[0], 'a');

      // var originalArray = [0,1];
      // var filledArray = fill(originalArray, 'a');
      // eq(filledArray[0], 'a');
      // eq(filledArray[1], 'a');
    },

    "a) It should fill holes in array.": function() {
      fail();
      // var arrayWithHoles = [,,,];
      // var filledArray = fill(arrayWithHoles, 'a');
      // eq(filledArray[0], 'a')
      // eq(filledArray[1], 'a')
      // eq(filledArray[2], 'a')

      // var arrayWithHoles = [0,,2];
      // var filledArray = fill(arrayWithHoles, 'a');
      // eq(filledArray[1], 'a')
    },

    "a) If value is an object, pass reference to object instead of a shallow copy of object.": function() {
      fail();
      // var originalArray = [0];
      // var originalObject = {};
      // var filledArray = fill(originalArray, originalObject);
      // eq(filledArray[0], originalObject);
    },

    "a) If no optionalStart, it should start filling indexes at array[0].": function() {
      fail();
      // var originalArray = [0,1];
      // var filledArray = fill(originalArray, 'a');
      // eq(filledArray[0], 'a');
    },
    "b) If optionalStart, it should start filling indexes at array[optionalStart].": function() {
      fail();
      // var originalArray = [0,1];
      // var filledArray = fill(originalArray, 'a', 1);
      // eq(filledArray[0], 0);
      // eq(filledArray[1], 'a');
    },

    "a) If no optionalEnd, it should fill all remaining indexes in array.": function() {
      fail();
      // var originalArray = [0,1];
      // var filledArray = fill(originalArray, 'a', 0);
      // TODO: 5) Double check this for loop is a good way to run a test.
      // for(var i=0; i<filledArray.length; i++){
      //    eq(filledArray[i], 'a');
      // }
    },
    "b) If optionalEnd, it should fill all indexes until array[optionalEnd].": function() {
      fail();
      // var originalArray = [0,1];
      // var filledArray = fill(originalArray, 'a', 0, 1);
      // eq(filledArray[0], 'a');
      // eq(filledArray[1], 1);
    },

    "a) If optionalStart is negative, start fill at array.length + optionalStart.": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // var filledArray = originalArray.fill("a", -1);
      // eq(filledArray[0], 0);
      // eq(filledArray[1], 1);
      // eq(filledArray[2], "a");

      // var originalArray = [0, 1, 2];
      // var filledArray = originalArray.fill("a", -2);
      // eq(filledArray[0], 0);
      // eq(filledArray[1], "a");
      // eq(filledArray[2], "a");
    },
    "b) If optionalEnd is negative, end fill at array.length + optionalEnd.": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // var filledArray = originalArray.fill("a", 0, -1);
      // eq(filledArray[0], "a");
      // eq(filledArray[1], "a");
      // eq(filledArray[2], 2);

      // var originalArray = [0, 1, 2];
      // var filledArray = originalArray.fill("a", 0, -2);
      // eq(filledArray[0], "a");
      // eq(filledArray[1], 1);
      // eq(filledArray[2], 2);
    },

    "a) It should fill with .call().": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, "a");
      // eq(originalArray[0] && originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, "a", 1);
      // eq(originalArray[0], 0);
      // eq(originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, "a", 1, 2);
      // eq(originalArray[0], 0);
      // eq(originalArray[1], "a");
      // eq(originalArray[2], 2);
    },
    "b) It should fill with .apply().": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, ["a"]);
      // eq(originalArray[0] && originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, ["a", 1]);
      // eq(originalArray[0], 0);
      // eq(originalArray[1] && originalArray[2], "a");

      // var originalArray = [0, 1, 2];
      // fill.call(originalArray, ["a", 1, 2]);
      // eq(originalArray[0], 0);
      // eq(originalArray[1], "a");
      // eq(originalArray[2], 2);
    },

    "a) If array is object and object has no length, object should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //   0:0
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 0);
    },
    "b) If array is object and object.length is <= 0, object should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   length: -10
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 0);
    },
    "c) If array is object and object.length is > 0, fill indexes up to object.length - 1.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   1:1,
      //   length: 1
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
      // eq(modifiedObject[1], 1);

      // var originalObject = {
      //   0:0,
      //   1:1,
      //   length: 2
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
      // eq(modifiedObject[1], 'a');

      // var originalObject = {
      //   0:0,
      //   1:1,
      //   length: 3
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
      // eq(modifiedObject[1], 'a');
      // eq(modifiedObject[2], 'a');
    },
    "d) If array is object and object.length is a string, and object.length can be converted to a number, fill indexes up to Number(object.length) - 1.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   length: '1'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 'a');
    },
    "e) If array is object and object.length is a string, and object.length cannot be converted to a number, object should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //   0:0,
      //   length: 'cow'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject[0], 0);
    },

    "a) If array is object it should never modify object.length.": function() {
      fail();
      // var originalObject = {
      //   0:0
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.hasOwnProperty("length"), false);

      // var originalObject = {
      //   0:0,
      //   length: -10
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, -10);

      // var originalObject = {
      //   0:0,
      //   length: 1
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, 1);

      // var originalObject = {
      //   0:0,
      //   length: 2
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, 2);

      // var originalObject = {
      //   0:0,
      //   length: '1'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, '1');

      // var originalObject = {
      //   0:0,
      //   length: 'cow'
      // };
      // var modifiedObject = fill.call(originalObject, 'a');
      // eq(modifiedObject.length, 'cow');
    },

    "a) It array is a string it should throw TypeError that states: Uncaught TypeError Cannot assign to read only property '0' of object '[object String]'. ": function() {
      fail();
      // var isTypeError = false;
      // try {
      //   var string = "string";
      //   fill.call(string, "a");
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    },
    "b) It array is null or undefined it should throw TypeError that states: Uncaught TypeError Cannot convert undefined or null to object. ": function() {
      fail();
      // var isTypeError = false;
      // try {
      //   var testNull = null;
      //   fill.call(testNull, "a");
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);

      // var isTypeError = false;
      // try {
      //   var testUndefined = undefined;
      //   fill.call(testUndefined, "a");
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    },
    "c) If array is a function, it should return function.": function() {
      fail();
      // var testFunction = function () {};
      // var filledFunction = Array.prototype.fill.call(testFunction, 'a');
      // eq(testFunction, filledFunction)
    },

    "d) If array is number or a boolean, it should convert array to object and return that?!": function() {
      fail();
      // TODO: 2) Figure out what happens with conversion of primitive to object.

      // Notes:
      // Spec: https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.fill
      // First step in Array.prototype.fill() is "Let O be ToObject(this value)."
      // Spec on ToObject method used in Array.prototype.fill(): https://www.ecma-international.org/ecma-262/6.0/#sec-toobject
      // The abstract operation ToObject converts argument to a value of type Object according to Table 13:
      // TODO: 1) Read this article. It appears to be very useful and sheds light on converting primtives to objects in JS:
      // JavaScript: Converting any value to an object: http://2ality.com/2011/04/javascript-converting-any-value-to.html

      // var number = 1;
      // var filledNumber = Array.prototype.fill.call(number, "a");
      // >>> returns {1}

      // var bool = true;
      // var filledBool = Array.prototype.fill.call(true, 'a');
      // >>> returns {true}
    }
  });
</script>
