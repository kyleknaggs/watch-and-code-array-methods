<script src="../../simpletest.js"></script>
<script>
  // Summary:
  // Reverses an array "in place."
  // The first array element becomes the last, and the last array element becomes the first.

  // Example:
  // var array = [0,1];
  // reverse(array)
  // >> returns array
  // >> array === [1,0];

  // Prototype implementation:

  // TODO: 1) Write prototype implementation for reverse.
  // function reverse(array) {
  // }

  // Function signature:
  // reverse(array);

  // Arguments:
  // array - The array to be reversed.

  // Return value:
  // array

  // TODO: 2) Figure out if there is a way to test for this:
  // It should not utilize an auxilliary data structure when creating new array.

  // Questions:
  // 1) What does "in place" mean as mentioned in first line of documentatin.
  // Best description found: http://doubtpoint.com/doubt/1356/what-do-you-mean-by-%22inplace%22-and-%22stable%22-sorting?
  // An in-place sorting algorithm directly modified the list that it receives as an input.
  // It does this instead of creting a new list that is then modified.

  // Useful References:
  // MDN Docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse
  // ECMAScript Specs: https://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.8
  // In Place definition referenced in MDN Docs: https://en.wikipedia.org/wiki/In-place_algorithm

  // Function Syntax:

  // function reverse(array /* ... */) {}

  tests({
    // Basic Requirements:
    "It should return an array.": function() {
      fail();
      // var originalArray = [];
      // var reversedArray = reverse(originalArray);
      // eq(Object.prototype.toString.call(reversedArray), "[object Array]");
    },
    "It should return the same array instead of creating a new array.": function() {
      fail();
      // var originalArray = [];
      // var reversedArray = reverse(originalArray);
      // eq(originalArray, reversedArray);
    },

    // Elements in Array:
    "a) If array.length < 2 it should not modify elements in array.": function() {
      fail();
      // var originalArray = [0];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray[0], 0);
    },
    "b) If array.length === 2 it should reverse the elements in array.": function() {
      fail();
      // var originalArray = [0, 1];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray[0], 1);
      // eq(reversedArray[1], 0);
    },
    "c) If array.length === 3 it should reverse the elements in array.": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray[0], 2);
      // eq(reversedArray[1], 1);
      // eq(reversedArray[2], 0);
    },
    "d) If array.length === 4 it should reverse the elements in array.": function() {
      fail();
      // var originalArray = [0, 1, 2, 3];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray[0], 3);
      // eq(reversedArray[1], 2);
      // eq(reversedArray[2], 1);
      // eq(reversedArray[3], 0);
    },
    "e) If array.length > 4 it should reverse the elements in array.": function() {
      fail();
      // var originalArray = [0, 1, 2, 3, 4];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray[0], 4);
      // eq(reversedArray[1], 3);
      // eq(reversedArray[2], 2);
      // eq(reversedArray[3], 1);
      // eq(reversedArray[4], 0);
    },

    "It should reverse holes.": function() {
      fail();
      // var originalArray = [, 1, 2];
      // var reversedArray = reverse(originalArray);
      // eq(2 in reversedArray, false);
    },

    "It should not reverse nested arrays": function() {
      fail();
      // var originalNestedArray = ['a', 'b'];
      // var indexZeroInOriginalNestedArray = originalNestedArray[0];
      // var indexOneInOriginalNestedArray = originalNestedArray[1];
      // var originalArray = [originalNestedArray, 1, 2];
      // var reversedArray = reverse(originalArray);
      // eq( reversedArray[2][0], indexZeroInOriginalNestedArray);
      // eq( reversedArray[2][1], indexOneInOriginalNestedArray);
    },

    // ---------------------

    // Array.length double check:
    "It should never modify array.length.": function() {
      fail();
      // var originalArray = [];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray.length, 0);

      // var originalArray = [0];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray.length, 1);

      // var originalArray = [0, 1];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray.length, 2);

      // var originalArray = [0, 1, 2];
      // var reversedArray = reverse(originalArray);
      // eq(reversedArray.length, 3);
    },

    // Call() and Apply():
    "It should reverse when used with .call().": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // var reversedArray = Array.prototype.reverse.call(originalArray);
      // eq(reversedArray[0], 2);
      // eq(reversedArray[1], 1);
      // eq(reversedArray[2], 0);
      // eq(reversedArray.length, 3);
    },
    "It should reverse when used with .apply().": function() {
      fail();
      // var originalArray = [0, 1, 2];
      // var reversedArray = Array.prototype.reverse.apply(originalArray);
      // eq(reversedArray[0], 2);
      // eq(reversedArray[1], 1);
      // eq(reversedArray[2], 0);
      // eq(reversedArray.length, 3);
    },

    // Objects and Array-like objects:
    "a) If object has no numerated keys, but object.length exists object should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //    length: 0
      //  };
      //  var reversedObject = Array.prototype.reverse.apply(originalObject);
      // eq(Object.keys(reversedObject).length, 1);
      // eq(reversedObject.length, 0);
    },
    "b) If object has numerated keys, but object.length does not exist, it should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //    0: 0,
      //    1: 1,
      //    2: 2,
      //  };
      //  var reversedObject = Array.prototype.reverse.apply(originalObject);
      // >> {0: 0, 1: 1, 2: 2}
    },
    "c) If object has numerated keys and object.length <= index of last numerated key, it should remain unchanged.": function() {
      fail();
      // var originalObject = {
      //    0: 0,
      //    1: 1,
      //    2: 2,
      //    length: -1
      //  };
      //  var reversedObject = Array.prototype.reverse.apply(originalObject);
      // >> {0: 0, 1: 1, 2: 2, length: -1}

      // var originalObject = {
      //   0: 0,
      //   1: 1,
      //   2: 2,
      //   length: 2
      // };
      // var reversedObject = Array.prototype.reverse.apply(originalObject);
      // >>> {0: 1, 1: 0, 2: 2, length: 2}
    },
    "d) If object has numerated keys and object.length > index of last numerated key, object reverses.": function() {
      fail();
      // var originalObject = {
      //   0: 0,
      //   1: 1,
      //   2: 2,
      //   length: 3
      // };
      // var reversedObject = Array.prototype.reverse.apply(originalObject);
      // >>> {0: 2, 1: 1, 2: 0, length: 3}

      // var originalObject = {
      //   0: 0,
      //   1: 1,
      //   2: 2,
      //   length: 4
      // };
      // var reversedObject = Array.prototype.reverse.apply(originalObject);
      // >>> {1: 2, 2: 1, 3: 0, length: 4}
    },

    "a) If object.length is not a number and object.length cannot be converted to a number, it should not reverse elements in object.": function() {
      fail();
      // var originalObject = {
      //   0: 0,
      //   1: 1,
      //   2: 2,
      //   length: "3"
      // };
      // var reversedObject = Array.prototype.reverse.apply(originalObject);
      // eq(reversedObject[0], 2)
      // eq(reversedObject[1], 1)
      // eq(reversedObject[2], 0)
    },
    "b) If object.length is not a number but object.length can be converted to a number, it should reverse elements in object.": function() {
      fail();
      // var originalObject = {
      //   0: 0,
      //   1: 1,
      //   2: 2,
      //   length: "cow"
      // };
      // var reversedObject = Array.prototype.reverse.apply(originalObject);
      // eq(reversedObject[0], 0)
      // eq(reversedObject[1], 1)
      // eq(reversedObject[2], 2)
    },

    // "If object has numerated keys and object.length > index of last numerated key, it should place value at first numerated key at object.length - 1.": function() {
    "a) If object.length === index of last numerated key + 1, numerated keys in object should remain the same.": function() {
      fail();
      // var originalObject = {
      //   0: 0,
      //   1: 1,
      //   2: 2,
      //   length: 3
      // };
      // var keysInOriginalObject = Object.keys(originalObject);
      // var reversedObject = Array.prototype.reverse.apply(originalObject);
      // var keysInReversedObject = Object.keys(reversedObject);
      // eq(keysInOriginalObject[0], keysInReversedObject[0])
      // eq(keysInOriginalObject[1], keysInReversedObject[1])
      // eq(keysInOriginalObject[2], keysInReversedObject[2])
    },
    "b) If object.length > index of last numerated key + 1, keys should shift by object.length - index of last numerated key.": function() {
      fail();
      // TODO: 3) Refactor keys when head is straight.
      // var originalObject = {
      //   0: 0,
      //   1: 1,
      //   2: 2,
      //   length: 4
      // };
      // var numerableKeysInOriginalObject = Object.keys(originalObject).slice(
      //   0,
      //   originalObject.length - 1
      // );
      // var indexOfLastNumeratedKeyInOriginalObject = 2;
      // var reversedObject = Array.prototype.reverse.apply(originalObject);
      // var numerableKeysInReversedObject = Object.keys(originalObject).slice(
      //   0,
      //   reversedObject.length - 1
      // );
      // var valueKeyShouldShift = Number(
      //   originalObject.length - indexOfLastNumeratedKeyInOriginalObject - 1
      // );
      // for (var i = 0; i < numerableKeysInReversedObject.length; i++) {
      //   console.log(
      //     numerableKeysInReversedObject[i],
      //     Number(numerableKeysInOriginalObject[i]) + Number(valueKeyShouldShift)
      //   );
      // }
    },

    "a) If array is number or a boolean, it should convert primitive value Object and return Object.": function() {
      fail();
      // var number = 123;
      // var reversedNumber = reverse.call(number);
      // eq(typeof filledNumber, "object");
      // eq(filledNumber.valueOf(), 123);

      // var bool = true;
      // var reversedNumber = reverse.call(bool);
      // eq(typeof reversedNumber, "object");
      // eq(reversedNumber.valueOf(), true);

      // var bool = false;
      // var reversedNumber = reverse.call(bool);
      // eq(typeof reversedNumber, "object");
      // eq(reversedNumber.valueOf(), false);
    },
    "b) If array is function, it should return function.": function() {
      fail();
      // var testFunction = function () {};
      // var reversedFunction = reverse(testFunction);
      // eq(testFunction, reversedFunction);
    },
    "c) If array is a string it should throw TypeError that states: Uncaught TypeError Cannot assign to read only property '0' of object '[object String]'.": function() {
      fail();
      // var isTypeError = false;
      // var errorMessage;
      // try {
      //   var string = "string";
      //   reverse.call(string);
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      //   errorMessage = e.message;
      // }
      // eq(isTypeError, true);
      // eq(
      //   errorMessage,
      //   "Cannot assign to read only property '0' of object '[object String]'"
      // );
    },
    "d) If array is null or undefined it should throw TypeError that states: Uncaught TypeError Cannot convert undefined or null to object.": function() {
      fail();
      // var isTypeError = false;
      // try {
      //   var testNull = null;
      //   reverse.call(testNull);
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);

      // var isTypeError = false;
      // try {
      //   var testUndefined = undefined;
      //   reverse.call(testUndefined);
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    }
  });
</script>
