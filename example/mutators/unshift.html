<script src="../../simpletest.js"></script>
<script>
  // Summary:
  // Adds one or more elements to the beginning of an array.

  // Example:
  // var array = [0];
  // unshift(array, 1);
  // >>> returns 2
  // >>> array = [1,0];

  // TODO: Finish writing prototype implementation of function.

  // Inside of parent loop, write child loop that starts at end of array

  // Write loop that starts at the end of the array:
  // Set i = array.length
  // if i !== 0
  // Retrive the value stored in array[i] and copy it to array[i+1]
  // Decrement i by 1
  // else
  // Store the value in elementToAdd in array[0]

  // Repeat the loop

  // Add the last element in the elementToAdd array
  // Starting at

  // TODO: Refactor sytax and remove console tests for prototype implementation.
  // Start -----------------------------

  // Prototype implementation:

  // function unshift(array, elements) {
  //   // Extract elementsToAdd from arguments array.
  //   var elementsToAdd = [];
  //   for (var i = 0; i < arguments.length - 1; i++) {
  //     elementsToAdd[i] = arguments[i + 1];
  //   }

  //   // Starting with the last elementToAdd:
  //   for (var i = elementsToAdd.length - 1; i >= 0; i--) {
  //     // Copy the value of all elements in array to the index above them:
  //     for (var j = array.length - 1; j >= 0; j--) {
  //       array[j + 1] = array[j];
  //     }
  //     array[0] = elementsToAdd[i];
  //   }

  //   return array.length;
  // }

  // End -----------------------------

  // Function signature:
  // unshift(array, elementsToAdd);

  // Arguments:
  // array - The array that will be modified.
  // elementsToAdd - The element/elements to add to the beginning of array.

  // Return value:
  // 1) The new length of the array after the element has been added.

  // Function Syntax:
  function unshift(array, elementsToAdd) {
    return array.length;
  }

  // Requirements:
  // i.e. What are the different arguments and combinations of these arguments that can be passed into the function's parameters.
  // i.e. array, empty array, no elementsToAdd, elementsToAdd, array is a traditional array, array is an array-like object...etc.

  tests({
    "1a) It should return a number.": function() {
      var emptyArray = [];
      var returnedValue = unshift(emptyArray);
      eq(Object.prototype.toString.call(returnedValue), "[object Number]");
    },

    "2a) It should return the length of array.": function() {
      var emptyArray = [];
      var unshiftedEmptyArray = unshift(emptyArray);
      eq(unshiftedEmptyArray, emptyArray.length);

      var array = [0];
      var unshiftedArray = unshift(array);
      eq(unshiftedArray, array.length);
    },

    "3a) If no elementsToAdd, array should remain unchanged.": function() {
      var emptyArray = [];
      var emptyArrayLength = emptyArray.length;
      var firstElementInEmptyArray = emptyArray[0];
      unshift(emptyArray);
      eq(emptyArrayLength, emptyArray.length);
      eq(firstElementInEmptyArray, emptyArray[0]);

      var array = [0];
      var originalArrayLength = array.length;
      var firstElementInOriginalArray = array[0];
      unshift(array);
      eq(originalArrayLength, array.length);
      eq(firstElementInOriginalArray, array[0]);
    },

    "4a) If elementsToAdd, it should add number of elementsToAdd to the beginning of array.": function() {
      fail();
      // var primitiveToAdd = 1;
      // var array = [];
      // unshift(array, primitiveToAdd);
      // eq(primitiveToAdd, array[0]);

      // var objectToAdd = {};
      // var array = [];
      // unshift(array, objectToAdd);
      // eq(objectToAdd, array[0]);

      // var array = [];
      // var firstElementInArray = 1;
      // unshift(array, firstElementInArray);
      // eq(firstElementInArray, array[0]);

      // var array = [];
      // var firstElementInArray = 1;
      // var secondElementInArray = 2;
      // unshift(array, firstElementInArray, secondElementInArray);
      // eq(firstElementInArray, array[0]);
      // eq(secondElementInArray, array[1]);
    },

    "5a) If should preserve holes in array.": function() {
      fail();
      // var arrayWithHoles = [,,,];
      // unshift(arrayWithHoles, 1);
      // eq(arrayWithHoles[0], 1);
      // eq(1 in arrayWithHoles, false);
      // eq(2 in arrayWithHoles, false);
      // eq(3 in arrayWithHoles, false);
    },

    "6a) If multiple elementsToAdd, it should increase array.length by the number of elementsToAdd.": function() {
      fail();
      // var array = [];
      // var originalArrayLength = array.length;
      // unshift(array, 1);
      // eq(array.length, originalArrayLength + 1);

      // var array = [];
      // var originalArrayLength = array.length;
      // unshift(array, 1, 2);
      // eq(array.length, originalArrayLength + 2);
    },

    "7a) It should add elements in the same order as they were passed into unshift as arguments.": function() {
      fail();
      // var array = [];
      // var firstArgument = 1;
      // var secondArgument = 2;
      // unshift(array, firstArgument,secondArgument);
      // eq(array.indexOf(firstArgument), array.indexOf(secondArgument)-1);
    },

    // When used with .call() or .apply():
    "8a) It should unshift when used with call().": function() {
      fail();
      // var array = [];
      // unshift.call(array, 1, 2));
      // eq(array[0], 1);
      // eq(array[1], 2);
      // eq(array.length, 2);
    },
    "8b) It should unshift when used with apply().": function() {
      fail();
      // var array = [];
      // var argumentsArray = [1,2]
      // unshift.call(array, argumentsArray));
      // eq(array[0], argumentsArray);
      // eq(array.length, 1);
    },

    "9a) If elementsToAdd, add numerated keys to object beginning at object[0].": function() {
      fail();
      // var object = {};
      // unshift.call(object, 1, 2);
      // eq(object[0], 1);
      // eq(object[1], 2);

      // var object = {10: 10};
      // unshift.call(object, 1, 2);
      // eq(object[0], 1);
      // eq(object[1], 2);
    },

    "10a) If elementsToAdd, a numerated key already exists, and number of elementsToAdd > numerated key, overwrite value of numerated key with elementToAdd.": function() {
      fail();
      // var valueAddedByUnshift = 'string';
      // var object = {0: 'string'};
      // unshift.call(object, valueAddedByUnshift);
      // eq(object[0], valueAddedByUnshift);
    },

    "11a) If no elementsToAdd and object.length >= 0, leave object.length unchanged.": function() {
      fail();
      // var objectWithLengthOfZero = {
      //   length: 0,
      // };
      // unshift.call(objectWithLengthOfZero);
      // eq(objectWithLengthOfZero.length, 0);

      // var objectWithLengthOfOne = {
      //   length: 1,
      // };
      // unshift.call(objectWithLengthOfOne);
      // eq(objectWithLengthOfOne.length, 1);
    },
    "11b) If no elementsToAdd and object.length does not exist, set object.length to 0.": function() {
      fail();
      // var object = {};
      // unshift.call(object);
      // eq(object.length, 0);
    },
    "11c) If no elementsToAdd, object.length is a number and object.length < 0, set object.length to 0.": function() {
      fail();
      // var objectWithNegativeLength = { length: -10 };
      // unshift.call(objectWithNegativeLength);
      // eq(objectWithNegativeLength.length, 0);
    },
    "9d) If no elementsToAdd and object.length is not a number, and object.length cannot be converted to a number set object.length to 0.": function() {
      fail();
      // var object = { length: "string" };
      // unshift.call(object);
      // eq(object.length, 0);
    },
    "11e) If no elementsToAdd and object.length is not a number, convert object.length to number.": function() {
      fail();
      // var object = { length: "0" };
      // unshift.call(object);
      // eq(object.length, 0);
    },

    "12a) If elementsToAdd and object.length does not exist, set object.length to number of elementsToAdd.": function() {
      fail();
      // var object = {};
      // unshift.call(object, 1, 2);
      // eq(object.length, 2);
    },
    "12b) If elementsToAdd, object.length is a number and object.length < 0, set object.length to number of elementsToAdd.": function() {
      fail();
      // var objectWithNegativeLength = { length: -10 };
      // unshift.call(objectWithNegativeLength, 1, 2);
      // eq(objectWithNegativeLength.length, 2);
    },
    "12c) If elementsToAdd and object.length >= 0, increase object.length by number of elementsToAdd.": function() {
      fail();
      // var objectWithLengthOfZero = {
      //   length: 0,
      // };
      // unshift.call(objectWithLengthOfZero, 1, 2);
      // eq(objectWithLengthOfZero.length, 2);

      // var objectWithLengthOfOne = {
      //   length: 1,
      // };
      // unshift.call(objectWithLengthOfOne, 1, 2);
      // eq(objectWithLengthOfOne.length, 3);
    },
    "12d) If elementsToAdd and object.length is not a number, set object.length equal to Number(object.length) + number of elementsToAdd.": function() {
      fail();
      // var object = { length: "0" };
      // unshift.call(object, 1, 2);
      // eq(object.length, 2);
    },
    "12e) If elementsToAdd and object.length is not a number, and object.length cannot be converted to a number set object.length equal to Number(object.length) + number of elementsToAdd.": function() {
      fail();
      // var object = { length: "string" };
      // unshift.call(object, 1, 2);
      // eq(object.length, 2);
    },

    // TODO: Write tests for uses of unshift using .call() that may throw an error:

    "13a) If array is a number or a boolean return 0.": function() {
      fail();
      // If array is a number:

      // var zero = 0;
      // var unshiftedValue = unshift.call(zero);
      // eq(unshiftedValue, 0);

      // var one = 1;
      // var unshiftedValue = unshift.call(zero);
      // eq(unshiftedValue, 0);

      // var two = 2;
      // var unshiftedValue = unshift.call(zero);
      // eq(unshiftedValue, 0);

      // If array is a bool:

      // var falseBool = false;
      // var unshiftedValue = unshift.call(falseBool);
      // eq(unshiftedValue, 0);

      // var trueBool = true;
      // var unshiftedValue = unshift.call(trueBool);
      // eq(unshiftedValue, 0);
    },

    // Note: Will not test for the string contained by the TypeError, just wanted to the tests to reflect the different reasons that TypeError occured:

    "14a) If array is a string, throw TypeError that states 'Cannot assign to read only property 'length' of object '[object String]''.": function() {
      fail();
      // var isTypeError = false;
      // try {
      //   var string = "string";
      //   unshift.call(string);
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    },

    "14b) If array is null or undefined throw a TypeError that states 'Cannot convert undefined or null to object'.": function() {
      fail();
      // If array is null:
      // var isTypeError = false;
      // try {
      //   var testNull = null;
      //   unshift.call(testNull);
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);

      // If array is undefined:
      // var isTypeError = false;
      // try {
      //   var testUndefined = undefined;
      //   unshift.call(testUndefined);
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    },

    "14c) If array is function throw a TypeError that states 'Cannot assign to read only property 'length' of function'.": function() {
      fail();
      // var isTypeError = false;
      // try {
      //   var testFunction = function() {};
      //   unshift.call(testFunction);
      // } catch (e) {
      //   isTypeError = e instanceof TypeError;
      // }
      // eq(isTypeError, true);
    }
  });
</script>
